<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
  <head>
    <meta http-equiv="content-type" content="text/html;
      charset=windows-1252">
    <title>semlit - Semi-Literate Documentation</title>
  </head>
  <body>
    <h1><a class="mozTocH1" name="mozTocId336658"></a>semlit Program
      Description</h1>
    <p>This is a <a
        href="https://github.com/fordsfords/semlit/tree/gh-pages">semi-literate


        document</a> for the program <tt>semlit.pl</tt> and it's shell
      wrapper <tt>semlit.sh</tt>.&nbsp; This program is used to create
      semi-literate documentation (of which this document is an
      example).&nbsp; Semi-literate documents like this are intended to
      explain the internals of a program, which is different than user
      documentation.&nbsp; If you are an end user, you probably want the
      <a href="https://github.com/fordsfords/semlit/tree/gh-pages">user
        document</a>.</p>
    =semlit,include, copyright.sldoc=<br>
    <ol class="readonly" id="mozToc">
      <!--mozToc h1 1 h2 2 h3 3 h4 4 h5 5 h6 6-->
      <li><a href="#mozTocId336658">semlit Program Description</a>
        <ol>
          <li><a href="#mozTocId638880">Introduction</a></li>
          <li><a href="#mozTocId41959">Program explanation: semlit.pl </a>
            <ol>
              <li><a href="#mozTocId462502">Main </a>
                <ol>
                  <li><a href="#mozTocId280226">Process command line</a></li>
                  <li><a href="#mozTocId259975">Read and process the
                      input sldoc file </a></li>
                  <li><a href="#mozTocId64">Fix up multiple source block
                      references</a></li>
                  <li><a href="#mozTocId139735">Write out the main
                      documentation html file and exit </a></li>
                  <li><a href="#mozTocId129472">Create a few html output
                      files </a></li>
                </ol>
              </li>
              <li><a href="#mozTocId142916">Function: process_doc_file()
                </a>
                <ol>
                  <li><a href="#mozTocId221127">Open sldoc input file</a></li>
                  <li><a href="#mozTocId702636">Read the file into
                      memory</a></li>
                  <li><a href="#mozTocId210353">For each semlit command
                      contained in that file</a></li>
                  <li><a href="#mozTocId612865">Execute the command</a></li>
                  <li><a href="#mozTocId447263">Replace the command with
                      the html returned by the command execution and
                      loop </a></li>
                  <li><a href="#mozTocId72820">return the processed html</a></li>
                  <li><a href="#mozTocId903260">Recursion</a></li>
                </ol>
              </li>
              <li><a href="#mozTocId193858">Function: semlit_cmd()</a>
                <ol>
                  <li><a href="#mozTocId638426">Command: tabstop</a></li>
                  <li><a href="#mozTocId897187">Command: srcfile </a></li>
                  <li><a href="#mozTocId897188">Command: initialsource </a></li>
                  <li><a href="#mozTocId395404">Command: include</a></li>
                  <li><a href="#mozTocId374013">Command: insert</a></li>
                  <li><a href="#mozTocId495366">Command: block </a></li>
                  <li><a href="#mozTocId911738">Command: endblock</a></li>
                  <li><a href="#mozTocId911739">Command: tooltip</a></li>
                </ol>
              </li>
              <li><a href="#mozTocId378007">Function: process_src_file()</a>
                <ol>
                  <li><a href="#mozTocId9443">Open the slsrc input file</a></li>
                  <li><a href="#mozTocId68855">Open the output source
                      html file</a></li>
                  <li><a href="#mozTocId958072">Open the output src file</a></li>
                  <li><a href="#mozTocId318560">For each input line in
                      the slsrc file:</a></li>
                  <li><a href="#mozTocId292395">If it is a semlit
                      command, process it</a></li>
                  <li><a href="#mozTocId511329">Else it is a source
                      line:</a></li>
                  <li><a href="#mozTocId457775">Write the line to the
                      src file</a></li>
                  <li><a href="#mozTocId786450">Html-ify the line</a></li>
                  <li><a href="#mozTocId331395">If there are active
                      source blocks accumulating:</a></li>
                  <li><a href="#mozTocId187875">Create doc link and
                      write source html file </a></li>
                  <li><a href="#mozTocId829189">Add the source line to
                      all of the active blocks</a></li>
                  <li><a href="#mozTocId409513">Else no active block,
                      write source html file without link</a></li>
                  <li><a href="#mozTocId103803">Close files and wrap up</a></li>
                  <li><a href="#mozTocId891933">Return html link to the
                      src file</a></li>
                </ol>
              </li>
              <li><a href="#mozTocId370472">Function: help() </a></li>
              <li><a href="#mozTocId370473">Function: file_get_contents() </a></li>
              <li><a href="#mozTocId389878">Error handling</a>
                <ol>
                  <li><a href="#mozTocId49613">Function: usage()</a></li>
                  <li><a href="#mozTocId899250">Function: err()</a></li>
                </ol>
              </li>
            </ol>
          </li>
          <li><a href="#mozTocId647222">Wrapper Shell Script</a></li>
        </ol>
      </li>
    </ol>
    <h2><a class="mozTocH2" name="mozTocId638880"></a>Introduction</h2>
    <p>This document describes the internals of the <tt>semlit.pl</tt>
      program, and is intended to be read by a programmer who wants to
      understand, maintain, and perhaps reuse the code.&nbsp; Before
      reading this documentation, you are expected to have a good
      user-level understanding of SEMLIT.&nbsp; Please be familiar <a
        href="https://github.com/fordsfords/semlit/tree/gh-pages">user
        document</a> with&nbsp; before starting this, unless you are
      just getting a feel for what SEMLIT documentation is like.<br>
    </p>
    <p>The main program is written in Perl. The reader is assumed to
      have at least <a
href="http://wiki.geeky-boy.com/w/index.php?title=Perl_for_C_Programmers">entry-level

        knowledge of Perl</a>. Some of the more-advanced Perl constructs
      are explained for the benefit of the novice.<br>
    </p>
    <p>There are two program source files:<br>
    </p>
    <ul>
      <li><b><span style="font-family: monospace;">=semlit,srcfile,semlit_pl.slsrc,semlit_pl.txt=</span></b>
        - (right-click and save as "semlit.pl") main program.</li>
=semlit,initialsource,semlit_pl.slsrc.html=
      <li><b><span style="font-family: monospace;">=semlit,srcfile,semlit_sh.slsrc,semlit_sh.txt=</span></b>
        - (right-click and save as "semlit.sh") wrapper shell script for
        <span style="font-family: monospace;">semlit.pl</span>.
        Strictly-speaking, this file is optional and is provided for
        convenience.</li>
    </ul>
    <p> </p>
    <h2><a class="mozTocH2" name="mozTocId41959"></a>Program
      explanation: <tt>semlit.pl</tt><br>
    </h2>
    <br>
    <h3><a class="mozTocH3" name="mozTocId462502"></a>Main<br>
    </h3>
    <p>Here are the high-level steps performed by the main semlit
      program:<br>
    </p>
    <ol>
      <li>Process command line.</li>
      <li>Read and process the input <b>sldoc</b> file. This has the
        side effect of reading the <b>slsrc</b> files and generating
        the <b>src</b> files.</li>
      <li>Fix up multiple source block references.<br>
      </li>
      <li>Write out the main documentation <b>html</b> file and exit.</li>
      <li>Create a few <b>html</b> output files.</li>
    </ol>
    <h4><a class="mozTocH3" name="mozTocId280226"></a>Process command
      line</h4>
    <p>Let's declare some global variables to hold values for program
      options, and set their default values: =semlit,insert,options=
      Note the use of the Perl built-in function <span
        style="font-family: monospace;">GetOptions</span>. This function
      does the work of parsing the command-line and setting new values
      into the global option variables. <span style="font-family:
        monospace;"></span>See the <a
        href="http://perldoc.perl.org/Getopt/Long.html">Perl
        documentation</a> if you are not familiar with the construct.<br>
    </p>
    <h4><a class="mozTocH3" name="mozTocId259975"></a>Read and process
      the input sldoc file<br>
    </h4>
    <p>The program assumes that there is a single master <b>sldoc</b>
      file supplied on the command line. So, early on we get that file
      name: =semlit,insert,infile= Note the use of the perl construct <span
        style="font-family: monospace;">scalar(@array)</span> to
      determine the number of elements in the array. There are shorter
      ways to do this (in terms of keystrokes), but I prefer the
      explicit construct. Makes it easier to spot. Also note the use of
      <span style="font-family: monospace;">-r file</span> to test if
      the file exists and is readable.<br>
    </p>
    <p>Once the file name is determined, we now process that input file:
      =semlit,insert,mainloop= Note that the function <a
        href="#mozTocId142916"><span style="font-family: monospace;">process_doc_file()</span></a>
      returns the html output for the documentation.<br>
    </p>
    <h4><a class="mozTocH3" name="mozTocId64"></a>Fix up multiple source
      block references</h4>
    <p>An <b>sldoc</b> file might insert the same block of source code
      multiple times. The source <b>html</b> will link to the first doc
      reference to it. How does the reader find the other references? At
      the end of an inserted source block, links will be inserted to
      adjacent references within the doc.<br>
    </p>
    <p>However, the <b>sldoc</b> file is processed sequentially. When a
      reference (<tt>insert</tt> command) is seen, it is not yet known
      if there will be subsequent references. So, a fixup step is added
      after the <b>sldoc</b> file is fully processed. That fixup step
      looks at each source block that has multiple references and adds
      the appropriate links (next/prev).<br>
    </p>
    <p>Since this step needs a count of the number of references, we
      need code in the <a href="#mozTocId193858"><tt>semlit_cmd()</tt></a>
      function to do the counting: =semlit,insert,countRefs= If <tt>$block_numrefs{$block_name}</tt>
      already exists, then this is not the first <tt>insert</tt> for
      this block.<br>
    </p>
    <p>Back to main and the fix-up step: =semlit,insert,fixRefs= The
      first reference has no "prev", so a link to the last reference is
      included. The last reference has no "next", so a link to the first
      reference is included. (The source <b>html</b> always links to
      the first reference.)<br>
    </p>
    <h4><a class="mozTocH3" name="mozTocId139735"></a>Write out the main
      documentation html file and exit<br>
    </h4>
    <p>A bit earlier in the program, the output file was opened:
      =semlit,insert,openOutHtml= Then, after the input file is
      processed, the returned html output is written to the output file:
      =semlit,insert,writeOut= The variable <span style="font-family:
        monospace;">$exit_status</span> is initialized to zero in main
      and is incremented each time an error is reported. Thus, if no
      errors are reported, the program exits with success (0).<br>
    </p>
    <h4><a class="mozTocH3" name="mozTocId129472"></a>Create a few html
      output files<br>
    </h4>
    <p>There are a couple of misc support files needed by the html
      documentation. Since the documentation is best viewed with html
      frames, the first file is the frameset: =semlit,insert,frameset=
      Note the use of Perl's "here document" <span style="font-family:
        monospace;">&lt;&lt;__EOF__</span> ... <span
        style="font-family: monospace;">__EOF__</span> See <a
        href="http://en.wikipedia.org/wiki/Here_document#Perl">Wikipedia</a>
      and the <a href="http://perldoc.perl.org/perlop.html#%3c%3cEOF">Perl
        documentation</a> if you are not familiar with this construct.
      Contrast this with the next code fragment.<br>
    </p>
    <p>By default, when the documentation is first brought up, there is no
      source to display in the source frame. So we need an almost blank page:
      =semlit,insert,blank= I didn't use a "here" document for this, but
      I could have. </p>
    <p>That initial blank page can be overridden with the "-i" command-line
      option, or with the "initialsource" semlit command. </p>

    <h3><a class="mozTocH3" name="mozTocId142916"></a>Function: <span
        style="font-family: monospace;">process_doc_file()</span><br>
    </h3>
    <p>The <span style="font-family: monospace;">process_doc_file()</span>
      function is called from the main program: =semlit,insert,mainloop=
      It is also called (recursively) from the semlit command <a
        href="#mozTocId395404"><span style="font-family: monospace;">include</span></a>.<br>
    </p>
    <p>The function starts out with: =semlit,insert,process_doc_file=
      Since this function can be called recursively, we save any
      existing file name and line number (they are restored before
      return).<br>
    </p>
    <p>The main function is to open an <b>sldoc</b> file, read the file
      and process the semlit commands, and return the documentation html
      output. Note that the <b>sldoc</b> input file is already in html
      form; once the file is read, all that remains to be done is to
      process the semlit commands. In the degenerate simple case of an <b>sldoc</b>
      file containing <span style="font-style: italic;">no</span>
      semlit commands at all, the output <b>html</b> file will be
      exactly equal to the <b>sldoc</b> input file. (An unlikely case
      since it is the semlit commands which provide the value of
      semi-literate documentation.)<br>
    </p>
    <p>Here are the high-level steps it performs:<br>
    </p>
    <ol>
      <li>Open <b>sldoc</b> input file.</li>
      <li>Read the file into memory.</li>
      <li>For each semlit command contained in that file:</li>
      <ol>
        <li>Execute the command.</li>
        <li>Replace the command with the html returned by the command
          execution and loop.</li>
      </ol>
      <li>Return the processed html.<br>
      </li>
    </ol>
    <p>In an earlier version, the program read the <b>sldoc</b> input
      file one line at a time. The line was tested to determine if it
      was an semlit command. If so, the line was executed and the line
      dropped. This approach worked fine when I used a simple text
      editor to create the html <b>sldoc</b> file. But editing html
      with a simple text editor is painful, error-prone, and
      inefficient. I really wanted to use an html editor. But html
      editors generally do not make it easy to control how the content
      is arranged on lines of the physical html file. I discovered that
      multiple semlit commands can be packed onto a single line, and
      even split across lines.<br>
    </p>
    <p>Fortunately, Perl provides powerful constructs which make this
      kind of processing easy. Instead of looking at the file
      line-by-line, the entire file can be read into a single string
      variable, and regular expression matching can be used to find the
      commands, one at a time. You will see this <a
        href="mozTocId210353">below</a>.<br>
    </p>
    <h4><a class="mozTocH4" name="mozTocId221127"></a>Open sldoc input
      file</h4>
    <p>The semlit program supports having libraries of <b>sldoc</b>
      files for standard boilerplate. I chose to model this after the C
      compiler: the programmer simply specifies the name of the file,
      and one or more search directories can be specified on the command
      line with the <span style="font-family: monospace;">-I</span>
      option. These directories are set up in the main program thus:
      =semlit,insert,initIncdirs= ... =semlit,insert,GetOptionsError=
      The <span style="font-family: monospace;">GetOptions()</span>
      function will parse out as many <span style="font-family:
        monospace;">-I</span> options that the user supplies and leaves
      the <span style="font-family: monospace;">@incdirs</span> array
      set with the directories (including ".").<br>
    </p>
    <p>Back in the process_doc_file() function, the file is opened as
      follows: =semlit,insert,openSldocFile= It loops through the array
      of include directories until the file can be opened. Note that
      almost the <a href="#mozTocId9443">same code</a> exists in <tt><a
          href="#mozTocId378007">process_src_file()</a>.</tt><br>
    </p>
    <h4><a class="mozTocH4" name="mozTocId702636"></a>Read the file into
      memory</h4>
    <p>Perl makes this easy: =semlit,insert,readsldoc= The <tt>chomp()</tt>
      function removes line delimiters, which, depending on platform,
      might be something other than linefeeds, and the <tt>join()</tt>
      combines the lines into one long string, and inserts linefeeds as
      line endings. Then, carriage returns, if any, are removed. This
      unifies different platforms. (<a href="#mozTocId318560">Similar
        code</a> can be found in <a href="#mozTocId378007"><tt>process_src_file()</tt></a>.)<br>
    </p>
    <h4><a class="mozTocH4" name="mozTocId210353"></a>For each semlit
      command contained in that file</h4>
    <p>The basic algorithm is to find the <span style="font-style:
        italic;">first</span> semlit command in the file, execute it,
      and then replace that semlit command with the results of the
      command. Note that it is possible that the replacement text
      contains semlit commands. So, each time a semlit command is
      processed, the entire file must be re-scanned from the beginning.
      Instead of trying to process the file line-by-line, the loop
      executes until there are no more commands to execute:
      =semlit,insert,findCommand= The variable <span
        style="font-family: monospace;">$o_delim</span> contains the
      semlit command delimiter and defaults to "<span
        style="font-family: monospace;">=</span>". The variable <span
        style="font-family: monospace;">$o_fs</span> contains the semlit
      command field separator and defaults to "<span style="font-family:
        monospace;">,</span>".<br>
    </p>
    <p>Note that the delimiter will certainly be used in the code
      without being associated with a semlit command, so the mere
      presence of the delimiter does not flag the start of a semlit
      command. The word "<span style="font-family: monospace;">semlit</span>"
      must immediately follow the delimiter ("<span style="font-family:
        monospace;">=semlit</span>"), and that must be followed by a
      field separator ("<span style="font-family: monospace;">,</span>").







      Also note that the match pattern captures the text between that
      field separator and the ending delimiter. That represents the
      semlit command keyword and parameters.<br>
    </p>
    <p>The next lines captures the file contents before and after the
      semlit command: =semlit,insert,prematch= Note the use of the <span
        style="font-family: monospace;">$PREMATCH</span> and <span
        style="font-family: monospace;">$POSTMATCH</span> built-in
      variables. See the <a href="http://perldoc.perl.org/perlvar.html">Perl





        documentation</a> if you are not familiar with this construct.<br>
    </p>
    <p>If errors are detected in the source files, it is helpful to
      print error messages which include the line number. This is
      challenging in this function because we are not processing on a
      line-by-line basis. It is further complicated by the fact that as
      commands are replaced by the returned text form command execution,
      the number of lines in the <span style="font-family: monospace;">$doctext</span>
      changes over time. However, since the commands are processed in
      order, we can calculate the line number by looking at the number
      of lines <span style="font-style: italic;">following</span> the
      command, and subtracting it from the total number:
      =semlit,insert,linecount= As you know from the <a
        href="http://perldoc.perl.org/functions/split.html">Perl
        documentation</a>, the <span style="font-family: monospace;">split()</span>
      function will by default not create an empty entry at the end
      (after the final '<span style="font-family: monospace;">\n</span>').<br>
    </p>
    <h4><a class="mozTocH4" name="mozTocId612865"></a>Execute the
      command</h4>
    <p>Now execute the command and capture the replacement text:
      =semlit,insert,executeCmd= The <a href="#mozTocId193858"><tt>semlit_cmd()</tt></a>
      function returns formatted html.<br>
    </p>
    <h4><a class="mozTocH4" name="mozTocId447263"></a>Replace the
      command with the html returned by the command execution and loop<br>
    </h4>
    <p>Replacing the matched semlit command with the resulting text is
      straight-forward: =semlit,insert,replText= This is where the
      number of lines in <span style="font-family: monospace;">$doctext</span>
      can change.<br>
    </p>
    <h4><a class="mozTocH4" name="mozTocId72820"></a>return the
      processed html</h4>
    <p>Finally: =semlit,insert,returnHtml=<br>
    </p>
    <h4><a class="mozTocH4" name="mozTocId903260"></a>Recursion</h4>
    <p>For the most part, Perl takes care of allowing functions to be
      recursive. However, we do have some global variables for error
      reporting which adds an extra challange:
      =semlit,insert,fileGlobals= By keeping the file name and line
      number as global variables, any function can report a
      user-friendly error message with a minimum of fuss.<br>
    </p>
    <p>Once the initial steps are completed, the <span
        style="font-family: monospace;">process_doc_file()</span>
      function is ready to start handling commands. But before it does,
      we want to save those global variables: =semlit,insert,saveFile=
      Then the command loop executes. When that is done, just before
      returning, we want to restore the global variables:
      =semlit,insert,restoreFile= You will see very similar code in the
      <a href="#mozTocId378007"><span style="font-family: monospace;">process_src_file()</span></a>
      function.<br>
    </p>
    <h3><a class="mozTocH3" name="mozTocId193858"></a>Function: <span
        style="font-family: monospace;">semlit_cmd()</span></h3>
    <p>The <a href="#mozTocId142916"><span style="font-family:
          monospace;">process_doc_file()</span></a> and <a
        href="#mozTocId378007"><span style="font-family: monospace;">process_src_file()</span></a>
      functions read input files, find semlit commands, and call <span
        style="font-family: monospace;">semlit_cmd()</span> to execute
      them. The delimiters, "<span style="font-family: monospace;">semlit</span>",







      and the first field separator are stripped, so that the passed-in
      command string starts with the command name.<br>
    </p>
    <h4><a class="mozTocH4" name="mozTocId638426"></a>Command: <span
        style="font-family: monospace;">tabstop</span></h4>
    <p>The <span style="font-family: monospace;">tabstop</span> command
      simply updates the <span style="font-family: monospace;">$tabstop</span>
      global variable: =semlit,insert,tabstop= The <span
        style="font-family: monospace;">$tabstop</span> variable is used
      directly by the built-in <span style="font-family: monospace;">Text::Tabs</span>
      Perl module: =semlit,insert,useTabs= Note that the <span
        style="font-family: monospace;">$tabstop</span> variable can
      also be set on the command line: =semlit,insert,GetOptionsError=
      So, where does this actually get used? Right here:
      =semlit,insert,expand= (In the function <a href="#mozTocId378007"><span
          style="font-family: monospace;">process_src_file()</span></a>.)
      The <span style="font-family: monospace;">expand()</span>
      function is part of the <span style="font-family: monospace;">Text::Tabs</span>
      module.<br>
    </p>
    <p>The <span style="font-family: monospace;">tabstop</span> command
      does not return any text (returns <span style="font-family:
        monospace;">""</span> - empty string).<br>
    </p>
    <h4><a class="mozTocH4" name="mozTocId897187"></a>Command: <span
        style="font-family: monospace;">srcfile</span><br>
    </h4>
    <p>The <span style="font-family: monospace;">srcfile</span> command
      is used to scan an <b>slsrc</b> file: =semlit,insert,srcfile=
      During the scan, any semlit commands found in the <b>slsrc</b>
      file are processed (usually <span style="font-family: monospace;">block</span>/<span
        style="font-family: monospace;">endblock</span> commands), and
      the source output files are created (both <b>html</b> and <b>src</b>).<br>
    </p>
    <p>The returned text is a link to the plaintext output <b>src</b>
      file. The author of the <b>sldoc</b> file expects this and
      positions the <tt>srcfile</tt> command such that a link to the <b>src</b>
      file makes sense. For example, near the top of this sldoc file,
      the <tt>srcfile</tt> commands are arranged in a bullet list. Each
      <tt>srcfile</tt> command is followed by the hint "(right-click and
      save)" followed by a short description of the file. </p>
    <h4><a class="mozTocH4" name="mozTocId897188"></a>Command: <span
        style="font-family: monospace;">initialsource</span><br>
    </h4>
    <p>The <span style="font-family: monospace;">initialsource</span> command
      is used to specify a file for initial display in the source frame:=semlit,insert,initialsource=
      The file must be the final file name, ending with ".html".
    </p>
    <p>There is no returned text.</p>
    <h4><a class="mozTocH4" name="mozTocId395404"></a>Command: <span
        style="font-family: monospace;">include</span></h4>
    <p>The <span style="font-family: monospace;">include</span> command
      is used to scan an <b>sldoc</b> file: =semlit,insert,include=
      Note that this represents a recursive call to <a
        href="#mozTocId142916"><span style="font-family: monospace;">process_doc_file()</span></a>.
      During the scan, the included file is processed the same way as
      the master <b>sldoc</b> file.<br>
    </p>
    <p>The returned text is simply the processed html of the included
      file.<br>
    </p>
    <h4><a class="mozTocH4" name="mozTocId374013"></a>Command: <span
        style="font-family: monospace;">insert</span></h4>
    <p>The <tt>insert</tt> command is used to insert into the document
      output <b>html</b> file a named block of source lines (from <b>slsrc</b>
      files): =semlit,insert,insert= Note the use of Perl's "here
      document" <span style="font-family: monospace;">&lt;&lt;__EOF__</span>
      ... <span style="font-family: monospace;">__EOF__</span> See <a
        href="http://en.wikipedia.org/wiki/Here_document#Perl">Wikipedia</a>
      and the <a href="http://perldoc.perl.org/perlop.html#%3c%3cEOF">Perl








        documentation</a> if you are not familiar with this construct.
      Also note that the source blocks <a href="#mozTocId829189">are
        stored</a> in the <span style="font-family: monospace;">%srcblocks</span>
      hash by the <a href="#mozTocId378007"><span style="font-family:
          monospace;">process_src_file()</span></a> function.<br>
    </p>
    <p>The endblock html comment becomes important during the <a
        href="#mozTocId64">final fix up step</a>; for blocks inserted
      multiple times, the comment is replaced with links to other
      references.<br>
    </p>
    <p>The returned text is the processed html of the source block.<br>
    </p>
    <h4><a class="mozTocH4" name="mozTocId495366"></a>Command: <tt>block</tt><br>
    </h4>
    <p>The <tt>block</tt> command essentially tells the <a
        href="#mozTocId378007"><tt>process_src_file()</tt></a> function
      to start storing source lines into a named block:
      =semlit,insert,block= Since it is possible for source lines to be
      included in multiple named blocks, the global hash <tt>%active_src_blocks</tt>
      is used to indicate which named blocks are accumulating.<br>
    </p>
    <h4><a class="mozTocH4" name="mozTocId911738"></a>Command: <tt>endblock</tt></h4>
    <p>The <tt>endblock</tt> command essentially tells the <a
        href="#mozTocId378007"><tt>process_src_file()</tt></a> function
      to stop storing source lines into the named block:
      =semlit,insert,endblock= The block name needs to be supplied
      because a nested block does not need to be fully-contained by the
      outer block. I.e. if multiple blocks are active, the <tt>endblock</tt>
      does not necessarily end the most-recently opened block.<br>
    </p>
    <h4><a class="mozToCH4" name="mozTocId911739"></a>Command: <tt>tooltip</tt></h4>
    <p>The <tt>tooltip</tt> command creates a keyword in block of text
      that can be hovered over for additional information.
      =semlit,insert,tooltip= The tooltip data is loaded from a 
      file on the local server, and the keyword is supplied as the last
      parameter. Note: the keyword cannot contain any spaces. 
    </p>
    <h3><a class="mozTocH3" name="mozTocId378007"></a>Function: <tt>process_src_file()</tt></h3>
    <p>The <tt>process_src_file()</tt> function is called from the <a
        href="#mozTocId897187"><tt>srcfile</tt></a> command. It reads
      and processes an <b>slsrc</b> file (program source code). Part of
      the processing is to generate two output files: a source <b>html</b>
      file, and a <b>src</b> file, stripped of its semlit commands and
      ready for compilation.<br>
    </p>
    <p>This function has conceptual similarities with the <a
        href="#mozTocId142916"><tt>process_doc_file()</tt></a> function,
      but there are important differences. The biggest difference is the
      overall approach to processing the file. Here, we process the <b>slsrc</b>
      file line-at-a-time. A line must contain either program source
      code, or a single semlit command (although that command might be
      enclosed in comment delimiters). Instead of replacing the command
      with returned content, the line containing the command is simply
      discarded.<br>
    </p>
    <p>Here are the high-level steps performed:<br>
    </p>
    <ol>
      <li>Open the <b>slsrc</b> input file.</li>
      <li>Open the output source <b>html</b> file.</li>
      <li>Open the output <b>src</b> file.</li>
      <li>For each input line in the <b>slsrc</b> file:</li>
      <ol>
        <li>If it is a semlit command, process it.</li>
        <li>Else it is a source line:</li>
        <ol>
          <li>Write the line to the <b>src</b> file.</li>
          <li>Html-ify the line.</li>
          <li>If there are active source blocks accumulating:</li>
          <ol>
            <li>Create doc link and write source <b>html</b> file.</li>
            <li>Add the source line to all of the active blocks.</li>
          </ol>
          <li>Else no active block, write source <b>html</b> file
            without link.<br>
          </li>
        </ol>
      </ol>
      <li>Close files and wrap up.</li>
      <li>Return html link to the <b>src</b> file.<br>
      </li>
    </ol>
    <h4><a class="mozTocH4" name="mozTocId9443"></a>Open the slsrc input
      file</h4>
    <p>Almost the <a href="#mozTocId221127">same code exists</a> in <a
        href="#mozTocId142916"><tt>process_doc_file()</tt></a>. Here we
      are opening an <b>slsrc</b> file which might be in any of the
      directories in the array <tt>@o_incdirs</tt>:
      =semlit,insert,openslsrc=<br>
    </p>
    <h4><a class="mozTocH4" name="mozTocId68855"></a>Open the output
      source html file</h4>
    <p>The output source <b>html</b> file is opened and some initial
      content is written: =semlit,insert,openSourceHtml= In addition to
      the initial html source, it also contains a link to the plain text
      <b>src</b> file which can be downloaded.<br>
    </p>
    <h4><a class="mozTocH4" name="mozTocId958072"></a>Open the output
      src file</h4>
    <p>The output <b>src</b> file is opened: =semlit,insert,openSrc=<br>
    </p>
    <h4><a class="mozTocH4" name="mozTocId318560"></a>For each input
      line in the slsrc file:</h4>
    <p>Read the <b>slsrc</b> file, line-by-line:
      =semlit,insert,foreachLine= The <tt>chomp()</tt> function removes
      line delimiter, which, depending on platform, might be something
      other than a linefeeds, and the next line adds a newline to be the
      line delimiter. Then, carriage returns, if any, are removed. This
      unifies different platforms. (<a href="#mozTocId702636">Similar
        code</a> can be found in <a href="#mozTocId142916"><tt>process_doc_file()</tt></a>.)</p>
    <h4><a class="mozTocH4" name="mozTocId292395"></a>If it is a semlit
      command, process it</h4>
    <p>The <b>slsrc</b> file contains semlit commands, usually <a
        href="#mozTocId495366"><tt>block</tt></a> and <a
        href="#mozTocId911738"><tt>endblock</tt></a>. Find and process
      them: =semlit,insert,ifsemlit=<br>
    </p>
    <h4><a class="mozTocH4" name="mozTocId511329"></a>Else it is a
      source line:</h4>
    <p>If the <b>slsrc</b> line does not contain a semlit command, then
      it is normal source code. =semlit,insert,elseSource= Note that
      source code lines are counted separately than input <b>slsrc</b>
      file lines (<tt>$cur_file_linenum</tt> counted above). The input
      line count (<tt>$cur_file_linenum</tt>) includes semlit command
      lines and is used when printing error messages by <a
        href="#mozTocId899250"><tt>err()</tt></a>, while the source code
      line count (<tt>$src_linenum</tt>) does not include semlit command
      lines and is used as the user-visible line number in the output
      source <b>html</b> file.<br>
    </p>
    <h4><a class="mozTocH4" name="mozTocId457775"></a>Write the line to
      the src file</h4>
    <p>Write the plaintext source line to the <b>src</b> file:
      =semlit,insert,writeSrc=<br>
    </p>
    <h4><a class="mozTocH4" name="mozTocId786450"></a>Html-ify the line</h4>
    <p>In advance of writing the line to the output source <b>html</b>
      file, expand tabs and convert the special characters '&amp;',
      '&lt;' and '&gt;' to their html forms:
      =semlit,insert,htmlifySource= Note that the <tt>expand()</tt>
      function is part of the <tt>Text::Tabs</tt> Perl module and uses
      the <tt>$tabstop</tt> global variable to control how it expands.<br>
    </p>
    <h4><a class="mozTocH4" name="mozTocId331395"></a>If there are
      active source blocks accumulating:</h4>
    <p>Check to see if this source line is inside one or more <tt>block</tt>/<tt>endblock</tt>
      constructs: =semlit,insert,ifActiveBlocks=<br>
    </p>
    <h4><a class="mozTocH4" name="mozTocId187875"></a>Create doc link
      and write source html file<br>
    </h4>
    <p>There is at least one named block active. Assuming there might be
      more than one, find the active block which was most-recently
      opened (is at the highest-numbered input line):
      =semlit,insert,createDocLink1= This sort construct orders the keys
      by descending <i>content</i> of the <tt>%active_srcblocks</tt>
      hash. Thus, <tt>$active_blocks[0]</tt> is the name of that
      most-recently opened block. This is used to construct the link
      back to the doc: =semlit,insert,createDocLink2=<br>
    </p>
    <h4><a class="mozTocH4" name="mozTocId829189"></a>Add the source
      line to all of the active blocks</h4>
    <p>For each active named <tt>block</tt>/<tt>endblock</tt>
      construct, add the source code to the <tt>%srcblocks</tt> hash:
      =semlit,insert,addBlocks= This is used by the <a
        href="#mozTocId374013"><tt>insert</tt></a> semlit command to
      insert the source block into the output doc <b>html</b> file.<br>
    </p>
    <h4><a class="mozTocH4" name="mozTocId409513"></a>Else no active
      block, write source html file without link</h4>
    <p>For source lines which are not contained in a <tt>block</tt>/<tt>endblock</tt>
      construct, no doc link is needed when writing to the output source
      <b>html</b> file: =semlit,insert,elseNoActiveBlocks=<br>
    </p>
    <h4><a class="mozTocH4" name="mozTocId103803"></a>Close files and
      wrap up</h4>
    <p>Close the files: =semlit,insert,closeWrap1= Note the many newlines
      printed. This is so that clicking on a line number which is near the
      end of the source file will still position that line of source at the
      top of the screen.</p>
    <p>Also, if the user
      accidentally started one or more named blocks but did not end
      them, print errors and force them ended:
      =semlit,insert,closeWrap2= Do it by calling <a
        href="#mozTocId193858"><tt>semlit_cmd()</tt></a> function,
      passing it the <a href="#mozTocId911738"><tt>endblock</tt></a>
      command (as if the <b>slsrc</b> file had it).<br>
    </p>
    <h4><a class="mozTocH4" name="mozTocId891933"></a>Return html link
      to the src file</h4>
    <p>But before we return, restore the <tt>$cur_file_name</tt> and <tt>$cur_file_linenum</tt>
      variables to their previous state. Then return.
      =semlit,insert,returnSrcLink= Since the call to <tt>process_src_file()</tt>
      came from semlit_cmd() executing the <a href="#mozTocId897187"><tt>srcfile</tt></a>
      command, and that command is used in the <b>sldoc</b> file, the
      thing we return is a link to the plaintext output <b>src</b>
      file.<br>
    </p>
    <h3><a class="mozTocH3" name="mozTocId370472"></a>Function: <tt>help()</tt><br>
    </h3>
    <p>First, let's declare a couple of globals that will be used for
      helping the user: =semlit,insert,usage= (The <a
        href="#mozTocId49613"><tt>usage()</tt></a> function also uses
      this.) In the <a href="#options">main code</a>, the "<span
        style="font-family: monospace;">-h</span>"option calls <tt>help()</tt>
      to print a more-extensive help: =semlit,insert,help= Note the use
      of Perl's "here document" <span style="font-family: monospace;">&lt;&lt;__EOF__</span>
      ... <span style="font-family: monospace;">__EOF__</span> See <a
        href="http://en.wikipedia.org/wiki/Here_document#Perl">Wikipedia</a>
      and the <a href="http://perldoc.perl.org/perlop.html#%3c%3cEOF">Perl








        documentation</a> if you are not familiar with this construct. </p>
    <h3><a class="mozTocH3" name="mozTocId370473"></a>Function: <tt>file_get_contents()</tt><br>
    </h3>
    <p>This is a simple routine to read the contents of a file for the purpose
      of filling in the <a href="#mozTocId911739">tooltips</a>: =semlit,insert,file_get_contents= </p>
    <h3><a class="mozTocH3" name="mozTocId389878"></a>Error handling</h3>
    <p>When there is an obvious user error in the invocation of the
      semlit program, the <a href="#mozTocId49613"><span
          style="font-family: monospace;">usage()</span></a> function is
      called.<br>
    </p>
    <p>For example: =semlit,insert,GetOptionsError= Note the use of the
      logical OR construct (<span style="font-family: monospace;">||</span>).









      Because of Perl's C-like <a
        href="http://en.wikipedia.org/wiki/Short-circuit_evaluation">short-circuit</a>
      evaluation, the right-hand expression (function call to <span
        style="font-family: monospace;">usage()</span>) is only executed
      if the left-hand side (function call to <span style="font-family:
        monospace;">GetOptions()</span>) returns false. I.e. usage is
      called if <span style="font-family: monospace;">GetOptions()</span>
      fails. Non-Perl programmers might be tempted to use a simple <span
        style="font-family: monospace;">if/then</span> construct, but
      the logical OR construct is such a common Perl idiom that the wise
      reader will learn it.<br>
    </p>
    <p>In other cases, an error is discovered in one of the input files,
      <b>sldoc</b> and/or <b>slsrc</b>. In those cases, the <a
        href="#mozTocId899250"><tt>err()</tt></a> function is called.<br>
    </p>
    <h4><a class="mozTocH4" name="mozTocId49613"></a>Function: <tt>usage()</tt></h4>
    <p>First, let's declare a couple of globals that will be used for
      helping the user: =semlit,insert,usage= (The <a
        href="#mozTocId49613"><tt>help()</tt></a> function also uses
      this.) The <tt>usage()</tt> function allows an optional error
      message to be passed in, which is printed before the usage string:
      =semlit,insert,usageFunct=<br>
    </p>
    <h4><a class="mozTocH4" name="mozTocId899250"></a>Function: <tt>err()</tt></h4>
    <p>The function err() is a programmer convenience which prints an
      error message, along with the file name and line number where the
      error was discovered. =semlit,insert,err= It also increments
      $exit_status, which starts out at zero (success):
      =semlit,insert,exit0= and is used when exiting the program:
      =semlit,insert,exit= Thus, a non-zero (failure) exit status also
      indicates how many errors there were.<br>
    </p>
    <h2><a class="mozTocH2" name="mozTocId647222"></a>Program
      Explanation: semlit.sh</h2>
    <p>As mentioned above, the first line of <tt>semlit.pl</tt> is a
      fairly common <a
        href="http://en.wikipedia.org/wiki/Shebang_%28Unix%29">shebang</a>:
      =semlit,insert,shebang= </p>
    <p>This Unix construct, combined with setting the executable bit on
      the file, is intended to allow the tool to be run by simply typing
      the file name as a command (assuming that the <span
        style="font-family: monospace;">PATH</span> environment variable
      is set up right). However, it does require that the physical
      location of the Perl interpreter be encoded directly in the file.
      Unfortunately, different Unix systems install Perl in different
      places - sometimes under <tt>/usr/local</tt>, sometimes in <tt>/bin</tt>,
      sometimes under <tt>/opt</tt>. <br>
    </p>
    <p>I vaguely remember that there is a clever way to re-code that
      line such that the shell will search for the Perl interpreter in
      the <tt>PATH</tt> environment variable. But I don't remember how
      to do it. <br>
    </p>
    <p>One way to run <tt>semlit.pl</tt> without having to set the Perl
      interpreter's full location is:<br>
      &nbsp;&nbsp;&nbsp; <span style="font-family: monospace;">perl </span><span
        style="font-style: italic; font-family: monospace;">SemLitPath</span><span
        style="font-family: monospace;">/semlit.pl</span> ... <br>
    </p>
    <p>But even that is somewhat unsatisfying for an experienced Unix
      user. Lazy as we are, we would prefer to let <span
        style="font-family: monospace;">PATH</span> do the work of
      finding the program, so we just enter:<br>
      &nbsp;&nbsp;&nbsp; <span style="font-family: monospace;">semlit</span>
      ...</p>
    <p>One common way to accomplish this is with a wrapper shell script
      which encapsulates any annoying details of running the tool. Hence
      the <tt>semlit</tt> file. <br>
    </p>
    <p>The first line of <tt>semlit</tt> is the standard <a
        href="http://en.wikipedia.org/wiki/Shebang_%28Unix%29">shebang</a>:
      =semlit,insert,sh_shebang= </p>
    <p>But this time it references the universally-respected location
      for a <a href="http://en.wikipedia.org/wiki/Bourne_shell">Bourne-compatible









        shell</a>. No chance that this won't work on some flavor of
      Unix. <br>
    </p>
    <p>Next save the initial working directory (so that we can get back
      to it). =semlit,insert,sh_iwd= </p>
    <p>I establish the convention that the wrapper script <em>must</em>
      be in the same directory as the perl script. So, the next thing to
      do is figure out which directory contains the wrapper which is
      running: =semlit,insert,sh_finddir= </p>
    <p>This might look more complicated than it needs to be. Isn't the
      first line enough? =semlit,insert,sh_dirname= </p>
    <p>No, it isn't. Suppose you are in your home directory, and you
      have placed the semlit files in <tt>$HOME/bin</tt>. Then let's
      say you execute the program by entering:<br>
      &nbsp;&nbsp;&nbsp; <span style="font-family: monospace;">bin/semlit</span>
      ...</p>
    <p>That is perfectly legal, and <tt>dirname $0</tt> will, not
      surprisingly, return <tt>bin</tt>, a relative path. But I want a
      fully-qualified path, so I include the three commands:
      =semlit,insert,sh_fix_tooldir= </p>
    <p>You simply <tt>cd</tt> to that potentially-relative location and
      use <tt>pwd</tt> to get the full path. Then <tt>cd</tt> back to
      the initial working directory. This is easier than trying to parse
      all the possible return values for <tt>dirname.</tt></p>
    <p>All that remains to be done is to run the perl interpreter as a
      comand (such that <tt>PATH</tt> is used):
      =semlit,insert,sh_runperl= </p>
  </body>
</html>
